/*
 * Ros.cpp
 *
 *  Created on: Oct 9, 2010
 *      Author: asher
 */

#include "Ros.h"
#include "string.h"
#include "WProgram.h"

#include <base_io.h>
#include <stdio.h>

void ros_init()
{
	/* FIXME: should io initialization be preformed by non-avrRos code? */
	ros_io_init();

	/* FIXME: this doesn't actually make sure the pc side grabs the ID, and it
	 * is unclear that waiting for said grabbing has any benifit */

	/* make sure that the program can grab the avr's id before we go into any
	 * other setup routines */
	uint8_t i;
	for (i = 0; i < 100; i++) {
		ros.spin();

		/* FIXME: arduino specific */
		delay(10);
	}
}

Ros::Ros(char *node_name, FILE *stream)
	: name(node_name)
	, packet_data_left(0)
	, buffer_index(0)
	, header(buffer)
	, com_state(header_state)
{}

void Ros::subscribe(char *topic, ros_cb funct, Msg * msg)
{
	int tag = getTopicTag(topic);
	this->cb_list[tag] = funct;
	this->msg_list[tag] = msg;
}

void Ros::publish(Publisher pub, Msg * msg)
{
	uint16_t byte_len = msg->serialize(this->outBuffer);
	this->send_pkt(PT_TOPIC, pub, this->outBuffer, byte_len);
}

void Ros::resetStateMachine()
{
	packet_data_left = 0;
	buffer_index = 0;
	com_state = header_state;
}

void Ros::processPkt(struct packet_header *header)
{
	switch(header->packet_type) {
	case PT_TOPIC:
		//ie its a valid topic tag
		//then deserialize the msg
		this->msg_list[header->topic_tag]->
				deserialize(header->data);
		//call the registered callback function
		this->cb_list[header->topic_tag](this->
				msg_list[header->topic_tag]);
		break;
	case PT_SERVICE:
		break;
	case PT_GETID:
		this->getID();
		break;
	}
}

void Ros::spin()
{
	int com_byte = getc(ros_io);

	while (com_byte != -1) {
		buffer[buffer_index] = com_byte;
		buffer_index++;

		if (com_state == header_state) {
			if (buffer_index == sizeof(packet_header)) {
				com_state = msg_data_state;
				this->packet_data_left = header->msg_length;
			}
		} else if (com_state == msg_data_state) {
			packet_data_left--;
			if (packet_data_left <= 0) {
				resetStateMachine();
				processPkt(header);
			}
		}

		com_byte = getc(ros_io);
	}
}

Publisher Ros::advertise(char *topic)
{

	//This section is to be dynamically generated by python script
	//this set of comparisons finds the topic id for the topic
	//generates the publisher and returns it

	return getTopicTag(topic);
}

void Ros::send_pkt(uint8_t packet_type, uint8_t topic_id,
               uint8_t *data, uint16_t data_len)
{
	fputc(packet_type, ros_io);
	fputc(topic_id, ros_io);

	/* FIXME: endianness */
	fwrite(&length, 1, sizeof(length), ros_io);
	fwrite(data, length, 1, ros_io);
}

/* Ordering of parameters to this function is non-intuitive, see replacement above */
__depricated
void Ros::send(uint8_t * data, uint16_t length, char packet_type, char topicID)
{
	send_pkt(packet_type, topicID, data, length);
}

void Ros::getID()
{
	uint16_t size = this->name.serialize(this->outBuffer);
	this->send_pkt(PT_GETID, 0, this->outBuffer, size);
}

Ros::~Ros()
{}
