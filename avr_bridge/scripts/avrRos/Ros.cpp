/*
 * Ros.cpp
 *
 * 
# Software License Agreement (BSD License)
#
# Copyright (c) 2011, Adam Stambler
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Adam Stambler, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
 */

#include "Ros.h"
#include "string.h"
#include "WProgram.h"

#include <base_io.h>
#include <stdio.h>
#include "String.h"

extern Publisher resp;
extern std_msgs::String response_msg;

Ros::Ros(char *node_name, uint8_t msg_type_ct, FILE *stream)
	: name(node_name)
	, packet_data_left(0)
	, buffer_index(0)
	, header(buffer)
	, com_state(header_state)
	, NUM_OF_MSG_TYPES(msg_type_ct)
{}

void Ros::subscribe(char *topic, ros_cb funct, Msg * msg)
{
	int tag = getTopicTag(topic);
	this->cb_list[tag] = funct;
	this->msg_list[tag] = msg;
}

void Ros::publish(Publisher pub, Msg * msg)
{
	uint16_t byte_len = msg->serialize(this->outBuffer);
	this->send_pkt(PT_TOPIC, pub, this->outBuffer, byte_len);
}

void Ros::resetStateMachine()
{
	packet_data_left = 0;
	buffer_index = 0;
	com_state = header_state;
}

void Ros::processPkt(struct packet_header *header)
{
	switch(header->packet_type) {
	case PT_TOPIC:
		//ie its a valid topic tag
		//then deserialize the msg
		this->msg_list[header->topic_tag]->
				deserialize(header->data);
		//call the registered callback function
		this->cb_list[header->topic_tag](this->
				msg_list[header->topic_tag]);
		break;
	case PT_SERVICE:
		break;
	case PT_GETID:
		this->getID();
		break;
	}
}

void Ros::spin(void)
{
	int com_byte =  getc(ros_io);


	while (com_byte != -1) {
		buffer[buffer_index] = com_byte;
		buffer_index++;

		if(com_state == header_state){
			if (buffer_index == sizeof(packet_header)) {
				com_state = msg_data_state;
				this->packet_data_left = header->msg_length;

				if (com_state == msg_data_state){
					if (!((header->packet_type == 0) || (header->packet_type == 255)))
							resetStateMachine();
					if (header->packet_type == 0){
						if (header->topic_tag >= NUM_OF_MSG_TYPES) resetStateMachine();
						if (header->msg_length>= 300) resetStateMachine();
					}
				}
			}
		} else if (com_state == msg_data_state) {
			packet_data_left--;
			if (packet_data_left < 0) {
				resetStateMachine();
				processPkt(header);
			}
		}

		com_byte = getc(ros_io);
	}
}

Publisher Ros::advertise(char *topic)
{
	//This section is to be dynamically generated by python script
	//this set of comparisons finds the topic id for the topic
	//generates the publisher and returns it

	return getTopicTag(topic);
}

void Ros::send_pkt(uint8_t packet_type, uint8_t topic_id,
               uint8_t *data, uint16_t data_len)
{
	fputc(packet_type, ros_io);
	fputc(topic_id, ros_io);

	/* FIXME: endianness */
	fwrite(&length, 1, sizeof(length), ros_io);
	fwrite(data, length, 1, ros_io);
}

/* Ordering of parameters to this function is non-intuitive, see replacement above */
__depricated
void Ros::send(uint8_t * data, uint16_t length, char packet_type, char topicID)
{
	send_pkt(packet_type, topicID, data, length);
}

void Ros::getID()
{
	uint16_t size = this->name.serialize(this->outBuffer);
	this->send_pkt(PT_GETID, 0, this->outBuffer, size);
}

Ros::~Ros()
{}
